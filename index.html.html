<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Venusian Gems</title>
  <style>
    :root {
      --cell-size: 9vmin;
      --gap-size: 1vmin;
      --board-size: calc((var(--cell-size) * 8) + (var(--gap-size) * 7));
    }
    
    body {
      background-color: #000;
      color: white;
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 2vmin;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 600px;
    }

    .info-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 15px;
      width: 100%;
      text-align: center;
    }

    h1 {
      font-size: 6vmin;
      color: #00ffe7;
      text-shadow: 0 0 10px #00ffe7, 0 0 20px #00ffe7;
      margin: 0 0 10px 0;
    }

    .score-timer-container {
      display: flex;
      justify-content: space-between;
      width: 100%;
      margin-bottom: 15px;
    }

    .score-timer {
      font-size: 4vmin;
      color: #fff;
      text-shadow: 0 0 5px #fff;
      padding: 5px 10px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
    }

    #timer {
      color: #ff0033;
      text-shadow: 0 0 5px #ff0033;
      font-weight: bold;
    }

    #resetButton {
      padding: 10px 20px;
      font-size: 4vmin;
      background-color: #ff0033;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      margin-top: 10px;
    }

    #board {
      width: var(--board-size);
      height: var(--board-size);
      display: grid;
      grid-template-columns: repeat(8, var(--cell-size));
      gap: var(--gap-size);
      position: relative;
      z-index: 0;
      touch-action: none;
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      border-radius: 18%;
      transition: transform 0.2s ease-in-out, box-shadow 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 5vmin;
      font-weight: bold;
      background: linear-gradient(145deg, rgba(255,255,255,0.2), rgba(255,255,255,0.05));
      box-shadow:
        inset 0 0 8px rgba(255,255,255,0.4),
        inset 0 5px 12px rgba(0,0,0,0.3),
        0 2px 8px rgba(0,0,0,0.4);
      color: white;
      user-select: none;
    }

    .cell.selected {
      transform: scale(1.1);
      box-shadow:
        inset 0 0 10px rgba(255,255,255,0.6),
        0 0 15px #fff,
        0 0 30px #fff;
      z-index: 5;
    }

    /* Colores √∫nicos */
    .red { background-color: #ff0033; }
    .yellow { background-color: #ffdd00; color: #333; }
    .green { background-color: #33cc33; }
    .pink { background-color: #ff66cc; }
    .purple { background-color: #aa33ff; }
    .orange { background-color: #ff8800; color: #333; }
    .aqua { background-color: #00cccc; }

    /* Im√°genes - no text content for these */
    .venusian {
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%23ff66cc"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="white">V</text></svg>');
      background-size: cover;
      background-position: center;
      color: transparent;
    }

    .mano {
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%2300cccc"/><text x="50" y="60" font-size="30" text-anchor="middle" fill="white">M</text></svg>');
      background-size: cover;
      background-position: center;
      color: transparent;
    }

    /* Lightning effect element */
    #lightning {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: white;
      opacity: 0;
      pointer-events: none;
      z-index: 999;
    }

    .flash {
      animation: flashUp 0.2s forwards;
    }

    @keyframes flashUp {
      0% { opacity: 0.8; }
      100% { opacity: 0; }
    }

    /* Message Overlay (Win/Loss) */
    #messageOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(255,255,255,0.1), rgba(0,0,0,0.95));
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
      flex-direction: column;
      text-align: center;
    }

    #messageOverlay h2 {
      font-size: 6vmin;
      color: #ff0;
      text-shadow: 0 0 10px #ff0, 0 0 20px #ff0, 0 0 30px #ff0;
      animation: blink 1s infinite;
      margin-bottom: 20px;
      padding: 0 5vmin;
    }

    #messageOverlay .message-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }

    #messageOverlay img.message-img {
      width: 20vmin;
      height: auto;
      animation: float 2s infinite ease-in-out;
    }

    #messageOverlay button.message-reset-button {
      margin-top: 30px;
      padding: 12px 24px;
      font-size: 4vmin;
      background-color: #ff0033;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
      100% { transform: translateY(0px); }
    }

    #messageOverlay.game-over h2 {
        color: #ff0033;
        text-shadow: 0 0 10px #ff0033, 0 0 20px #ff0033, 0 0 30px #ff0033;
    }

    @media (min-width: 768px) {
      .game-container {
        flex-direction: row;
        align-items: flex-start;
        justify-content: center;
        gap: 30px;
      }
      
      .info-panel {
        width: auto;
        margin-bottom: 0;
        align-items: flex-start;
        text-align: left;
      }
      
      .score-timer-container {
        flex-direction: column;
        gap: 10px;
      }
    }

    .instructions {
      margin-top: 20px;
      text-align: center;
      font-size: 3vmin;
      color: #00ffe7;
      max-width: 90%;
    }
  </style>
  <!-- Define el color de la barra superior del navegador en el telefono -->
  <meta name="theme-color" content="#000000"/> 
</head>
<body>

  <div class="game-container">
    <div class="info-panel">
      <h1>Venusian Gems</h1>
      <div class="score-timer-container">
        <div class="score-timer" id="score">Score: 0</div>
        <div class="score-timer" id="timer">Time: 60</div>
      </div>
      <button id="resetButton" onclick="resetGame()">üîÑ Reset</button>
    </div>
    
    <div id="board"></div>
  </div>

  <div class="instructions">
    <p>Selecciona una gema y luego una adyacente para intercambiarlas.<br>Forma la palabra VENUSIAN para ganar!</p>
  </div>

  <div id="lightning"></div>

  <div id="messageOverlay">
    <div class="message-content">
        <h2 id="messageTitle"></h2>
        <div style="display: flex; gap: 20px;">
          <div class="cell venusian"></div>
          <div class="cell mano"></div>
        </div>
        <button class="message-reset-button" onclick="resetGame()">Play Again ‚û°Ô∏è</button>
    </div>
  </div>

  <script>
    // Variables globales
    const board = document.getElementById("board");
    const scoreDisplay = document.getElementById("score");
    const timerDisplay = document.getElementById("timer");
    const messageOverlay = document.getElementById("messageOverlay");
    const messageTitle = document.getElementById("messageTitle");
    const lightning = document.getElementById("lightning");

    let gameLoop;
    let timerCountdown;
    let timeLeft = 60;
    let gameActive = false;

    const letterMap = {
      red: 'V', yellow: 'E', green: 'N', pink: 'U', purple: 'S', orange: 'I', aqua: 'A',
      venusian: 'N',
      mano: 'N'
    };

    const colors = ["red", "yellow", "green", "pink", "purple", "orange", "aqua", "venusian", "mano"];
    const boardSize = 8;
    const totalCells = boardSize * boardSize;
    let cells = [];
    let selectedCell = null;
    let score = 0;

    // --- Game Logic ---
    function getRandomColor() {
      return colors[Math.floor(Math.random() * colors.length)];
    }

    function createBoard() {
      cells = [];
      board.innerHTML = '';

      for (let i = 0; i < totalCells; i++) {
        const cell = document.createElement("div");
        cell.setAttribute("id", i);
        cell.classList.add("cell");

        const color = getRandomColor();
        cell.classList.add(color);
        cell.textContent = letterMap[color] || "";

        // Eventos para mouse y touch
        cell.addEventListener("mousedown", handleCellMouseDown);
        cell.addEventListener("touchstart", handleCellTouchStart, { passive: true });
        
        board.appendChild(cell);
        cells.push(cell);
      }
      console.log("Tablero creado con gemas iniciales.");
    }

    function handleCellMouseDown(e) {
      if (!gameActive) {
        handleFirstGameInteraction();
      }
      
      const cellId = parseInt(e.currentTarget.id);
      selectCell(cellId);
    }

    function handleCellTouchStart(e) {
      if (!gameActive) {
        handleFirstGameInteraction();
      }
      
      e.preventDefault();
      const cellId = parseInt(e.currentTarget.id);
      selectCell(cellId);
    }

    function selectCell(cellId) {
      if (selectedCell === null) {
        // Primera selecci√≥n
        selectedCell = cellId;
        cells[cellId].classList.add("selected");
      } else if (selectedCell === cellId) {
        // Desseleccionar
        cells[cellId].classList.remove("selected");
        selectedCell = null;
      } else {
        // Intentar intercambiar con la celda seleccionada previamente
        const rowSelected = Math.floor(selectedCell / boardSize);
        const colSelected = selectedCell % boardSize;
        const rowNew = Math.floor(cellId / boardSize);
        const colNew = cellId % boardSize;
        
        const isAdjacent = (
            (Math.abs(rowSelected - rowNew) === 1 && colSelected === colNew) ||
            (Math.abs(colSelected - colNew) === 1 && rowSelected === rowNew)
        );
        
        if (isAdjacent) {
          cells[selectedCell].classList.remove("selected");
          swapGems(selectedCell, cellId);
          checkMatchesAndRefill();
          selectedCell = null;
        } else {
          // Desseleccionar la anterior y seleccionar la nueva
          cells[selectedCell].classList.remove("selected");
          selectedCell = cellId;
          cells[cellId].classList.add("selected");
        }
      }
    }

    function handleFirstGameInteraction() {
        console.log("Primera interacci√≥n detectada. Iniciando juego.");
        startGameLoop();
        gameActive = true;
    }

    function startGameLoop() {
      clearInterval(gameLoop);
      clearInterval(timerCountdown);

      timeLeft = 60;
      timerDisplay.textContent = `Time: ${timeLeft}`;
      
      gameLoop = setInterval(() => {
        if (!gameActive) {
            clearInterval(gameLoop);
            return;
        }
        checkMatchesAndRefill();
        checkWin();
      }, 200);

      timerCountdown = setInterval(() => {
        if (!gameActive) {
            clearInterval(timerCountdown);
            return;
        }
        timeLeft--;
        timerDisplay.textContent = `Time: ${timeLeft}`;
        if (timeLeft <= 0) {
          endGameByTime();
        }
      }, 1000);
      console.log("Bucle del juego y temporizador iniciados.");
    }

    function resetGame() {
      console.log("Reiniciando juego...");
      gameActive = false;
      clearInterval(gameLoop);
      clearInterval(timerCountdown);

      messageOverlay.style.display = "none";
      messageOverlay.classList.remove('game-over');
      
      score = 0;
      updateScore();
      selectedCell = null;
      createBoard();

      console.log("Juego reiniciado. Listo para nueva partida.");
    }

    function swapGems(id1, id2) {
        const cell1 = cells[id1];
        const cell2 = cells[id2];

        const tempColor1 = cell1.classList[1];
        const tempText1 = cell1.textContent;
        const tempColor2 = cell2.classList[1];
        const tempText2 = cell2.textContent;

        cell1.className = "cell";
        if (tempColor2) cell1.classList.add(tempColor2);
        cell1.textContent = tempText2;

        cell2.className = "cell";
        if (tempColor1) cell2.classList.add(tempColor1);
        cell2.textContent = tempText1;
    }

    function showLightningFlash() {
      lightning.classList.add("flash");
      setTimeout(() => lightning.classList.remove("flash"), 200);
    }

    function collectMatches() {
        let matchesFound = false;
        let matchedIndexes = new Set();

        for (let i = 0; i < totalCells; i++) {
            if (i % boardSize <= boardSize - 3) {
                const color1 = cells[i]?.classList[1];
                if (!color1 || color1 === "cell") continue;

                if (cells[i+1]?.classList[1] === color1 && cells[i+2]?.classList[1] === color1) {
                    matchesFound = true;
                    matchedIndexes.add(i); matchedIndexes.add(i+1); matchedIndexes.add(i+2);
                    if (i % boardSize <= boardSize - 4 && cells[i+3]?.classList[1] === color1) {
                        matchedIndexes.add(i+3);
                        if (i % boardSize <= boardSize - 5 && cells[i+4]?.classList[1] === color1) {
                            matchedIndexes.add(i+4);
                        }
                    }
                }
            }
        }

        for (let i = 0; i < totalCells; i++) {
            if (i < totalCells - (boardSize * 2)) {
                const color1 = cells[i]?.classList[1];
                if (!color1 || color1 === "cell") continue;

                if (cells[i + boardSize]?.classList[1] === color1 && cells[i + (boardSize * 2)]?.classList[1] === color1) {
                    matchesFound = true;
                    matchedIndexes.add(i); matchedIndexes.add(i + boardSize); matchedIndexes.add(i + (boardSize * 2));
                    if (i < totalCells - (boardSize * 3) && cells[i + (boardSize * 3)]?.classList[1] === color1) {
                        matchedIndexes.add(i + (boardSize * 3));
                        if (i < totalCells - (boardSize * 4) && cells[i + (boardSize * 4)]?.classList[1] === color1) {
                            matchedIndexes.add(i + (boardSize * 4));
                        }
                    }
                }
            }
        }
        return Array.from(matchedIndexes);
    }

    function checkMatchesAndRefill() {
        let matchesFoundThisCycle = false;
        let iteration = 0;
        const maxIterations = 10;

        do {
            iteration++;
            if (iteration > maxIterations) {
                console.error("checkMatchesAndRefill: M√°ximas iteraciones alcanzadas.");
                break;
            }

            let matches = collectMatches();
            if (matches.length > 0) {
                matchesFoundThisCycle = true;
                showLightningFlash();
                
                matches.forEach(idx => {
                    cells[idx].className = "cell";
                    cells[idx].textContent = "";
                    score += 10;
                });
                updateScore();
                
                moveGemsDown();
            } else {
                matchesFoundThisCycle = false;
            }
        } while (matchesFoundThisCycle);

        return matchesFoundThisCycle;
    }

    function updateScore() {
      scoreDisplay.textContent = "Score: " + score;
    }

    function moveGemsDown() {
        for (let col = 0; col < boardSize; col++) {
            let emptySpots = [];
            for (let row = boardSize - 1; row >= 0; row--) {
                const idx = row * boardSize + col;
                if (cells[idx].classList.length === 1) {
                    emptySpots.push(idx);
                } else if (emptySpots.length > 0) {
                    const targetIdx = emptySpots.shift();
                    
                    cells[targetIdx].className = "cell";
                    cells[targetIdx].classList.add(cells[idx].classList[1]);
                    cells[targetIdx].textContent = cells[idx].textContent;

                    cells[idx].className = "cell";
                    cells[idx].textContent = "";

                    emptySpots.push(idx);
                }
            }
        }

        for (let i = 0; i < totalCells; i++) {
            if (cells[i].classList.length === 1) {
                const newColor = getRandomColor();
                cells[i].classList.add(newColor);
                cells[i].textContent = letterMap[newColor] || "";
            }
        }
    }

    function checkWin() {
        if (!gameActive) return;

        const boardLetters = cells.map(cell => {
            const cellClasses = Array.from(cell.classList);
            if (cellClasses.includes('venusian') || cellClasses.includes('mano')) {
                return 'N';
            }
            return cell.textContent || "";
        }).join('');
        const targetWord = "VENUSIAN";

        // Check horizontally
        for (let row = 0; row < boardSize; row++) {
            const rowString = boardLetters.substring(row * boardSize, (row * boardSize) + boardSize);
            if (rowString.includes(targetWord)) {
                console.log(`Victoria: 'VENUSIAN' encontrado horizontalmente en la fila ${row}.`);
                showWinMessage();
                return;
            }
        }

        // Check vertically
        for (let col = 0; col < boardSize; col++) {
            let colString = '';
            for (let row = 0; row < boardSize; row++) {
                const cellClasses = Array.from(cells[col + (row * boardSize)].classList);
                 if (cellClasses.includes('venusian') || cellClasses.includes('mano')) {
                    colString += 'N';
                } else {
                    colString += cells[col + (row * boardSize)].textContent || "";
                }
            }
            if (colString.includes(targetWord)) {
                console.log(`Victoria: 'VENUSIAN' encontrado verticalmente en la columna ${col}.`);
                showWinMessage();
                return;
            }
        }
    }

    function showWinMessage() {
      console.log("¬°Victoria!");
      gameActive = false;
      clearInterval(gameLoop);
      clearInterval(timerCountdown);

      messageOverlay.style.display = "flex";
      messageTitle.textContent = "VENUSLICIOUS, you are Venusian People!!! üöÄ";
      messageOverlay.classList.remove('game-over');
    }

    function endGameByTime() {
      console.log("¬°Se acabo el tiempo! Game Over.");
      gameActive = false;
      clearInterval(gameLoop);
      clearInterval(timerCountdown);

      messageOverlay.style.display = "flex";
      messageTitle.textContent = "¬°Se acabo el tiempo! ¬°Game Over!";
      messageOverlay.classList.add('game-over');
    }

    // --- Initial Setup ---
    createBoard();
    console.log("Configuraci√≥n inicial completa. Esperando la primera interacci√≥n del usuario.");
  </script>
</body>
</html>